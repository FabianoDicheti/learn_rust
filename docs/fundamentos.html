<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fundamentos da Linguagem - Rust B√°sico em PTBR</title>
    <link rel="stylesheet" href="css/style.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet">
</head>
<body>
    <header class="header">
        <div class="container">
            <div class="header-content">
                <div class="logo-section">
                    <img src="images/rust_logo_gear.png" alt="Logo do Rust">
                    <img src="images/ferris_crab.png" alt="Ferris - Mascote do Rust">
                    <h1>Rust B√°sico em PTBR</h1>
                </div>
            </div>
        </div>
    </header>

    <nav class="nav">
        <div class="container">
            <ul>
                <li><a href="index.html">In√≠cio</a></li>
                <li><a href="instalacao.html">Instala√ß√£o</a></li>
                <li><a href="primeiro-projeto.html">Iniciando Um Projeto</a></li>
                <li><a href="fundamentos.html" class="active">Fundamentos</a></li>
                <li><a href="ownership.html">Ownership</a></li>
                <li><a href="testes.html">Testes</a></li>
                <li><a href="crates.html">Crates</a></li>
                <li><a href="recursos.html">Recursos</a></li>
            </ul>
        </div>
    </nav>

    <main class="main container">
        <h1 class="section-title">Fundamentos da Linguagem Rust</h1>
        
        <p>Agora que voc√™ j√° criou meiro projeto, vamos explorar os conceitos fundamentais da linguagem Rust. Estes conceitos formam a base para tudo que voc√™ far√° com Rust.</p>

        <h2 class="section-subtitle">Vari√°veis e Imutabilidade</h2>
        
        <p>Uma das caracter√≠sticas mais distintivas do Rust √© que <strong>vari√°veis s√£o imut√°veis por padr√£o</strong>. Isso significa que, uma vez que voc√™ atribui um valor a uma vari√°vel, n√£o pode alter√°-lo.</p>
        
        <div class="comparison-container">
            <div class="comparison-item">
                <div class="comparison-title"> Vari√°vel Imut√°vel</div>
                <div class="code-block">
let x = 10;
<span class="comment">// x = 20; // ERRO! N√£o pode alterar</span>

println!("x = {}", x); <span class="comment">// x = 10</span>
                </div>
                <p>Por padr√£o, vari√°veis n√£o podem ser alteradas ap√≥s a atribui√ß√£o inicial.</p>
            </div>
            
            <div class="comparison-item">
                <div class="comparison-title"> Vari√°vel Mut√°vel</div>
                <div class="code-block">
let <span class="highlight">mut</span> y = 10;
y = 20; <span class="comment">// OK! Pode alterar</span>
y += 5; <span class="comment">// y agora √© 25</span>

println!("y = {}", y); <span class="comment">// y = 25</span>
                </div>
                <p>Use a palavra-chave <code>mut</code> para tornar uma vari√°vel mut√°vel.</p>
            </div>
        </div>
        
        <div class="info-box">
            <h4><i class="fas fa-lightbulb"></i> Por que Imutabilidade por Padr√£o?</h4>
            <p>A imutabilidade por padr√£o torna o c√≥digo mais previs√≠vel e evita bugs comuns. Voc√™ precisa ser expl√≠cito quando quer mutabilidade, o que for√ßa voc√™ a pensar sobre quando e onde os dados podem mudar.</p>
        </div>

        <h2 class="section-subtitle">Tipos de Dados</h2>
        
        <p>Rust tem tipagem est√°tica forte, mas consegue inferir a maioria dos tipos automaticamente. Aqui est√£o os tipos mais comuns:</p>
        
        <div class="code-block">
<span class="comment">// N√∫meros inteiros</span>
let idade: <span class="highlight">u32</span> = 25;        <span class="comment">// unsigned 32-bit (0 a 4,294,967,295)</span>
let temperatura: <span class="highlight">i32</span> = -10;   <span class="comment">// signed 32-bit (-2,147,483,648 a 2,147,483,647)</span>
let pequeno: <span class="highlight">u8</span> = 255;       <span class="comment">// unsigned 8-bit (0 a 255)</span>

<span class="comment">// N√∫meros decimais</span>
let altura: <span class="highlight">f64</span> = 1.75;      <span class="comment">// 64-bit float (padr√£o)</span>
let peso: <span class="highlight">f32</span> = 70.5;       <span class="comment">// 32-bit float</span>

<span class="comment">// Texto</span>
let nome: <span class="highlight">&str</span> = "Jo√£o";     <span class="comment">// string slice (refer√™ncia)</span>
let sobrenome: <span class="highlight">String</span> = String::from("Silva"); <span class="comment">// owned string</span>

<span class="comment">// Booleano</span>
let ativo: <span class="highlight">bool</span> = true;      <span class="comment">// true ou false</span>

<span class="comment">// Caractere Unicode</span>
let letra: <span class="highlight">char</span> = 'ü¶Ä';       <span class="comment">// 4 bytes, suporta Unicode</span>
        </div>
        
        <div class="info-box tip">
            <h4><i class="fas fa-magic"></i> Infer√™ncia de Tipos</h4>
            <p>Na maioria dos casos, voc√™ n√£o precisa especificar o tipo explicitamente:</p>
            <div class="code-block">
let numero = 42;        <span class="comment">// Rust infere i32</span>
let pi = 3.14;          <span class="comment">// Rust infere f64</span>
let nome = "Ferris";    <span class="comment">// Rust infere &str</span>
            </div>
        </div>

        <h2 class="section-subtitle">Fun√ß√µes</h2>
        
        <p>Fun√ß√µes s√£o blocos de c√≥digo reutiliz√°veis. Em Rust, elas s√£o definidas com a palavra-chave <code>fn</code>:</p>
        
        <div class="code-block">
<span class="comment">// Fun√ß√£o simples sem retorno</span>
fn saudar() {
    println!("Ol√°, mundo!");
}

<span class="comment">// Fun√ß√£o com par√¢metros</span>
fn saudar_pessoa(nome: &str) {
    println!("Ol√°, {}!", nome);
}

<span class="comment">// Fun√ß√£o com retorno</span>
fn soma(a: i32, b: i32) -> i32 {
    a + b <span class="comment">// Retorno impl√≠cito (sem ponto-e-v√≠rgula!)</span>
}

<span class="comment">// Fun√ß√£o com retorno expl√≠cito</span>
fn multiplicacao(a: i32, b: i32) -> i32 {
    return a * b; <span class="comment">// Retorno expl√≠cito com return</span>
}

fn main() {
    saudar();
    saudar_pessoa("Ferris");
    
    let resultado = soma(10, 5);
    println!("10 + 5 = {}", resultado);
    
    let produto = multiplicacao(4, 7);
    println!("4 √ó 7 = {}", produto);
}
        </div>
        
        <div class="rules-container">
            <div class="rule-item">
                <div class="rule-icon"><i class="fas fa-arrow-right"></i></div>
                <div><strong>Retorno impl√≠cito</strong>: A √∫ltima express√£o (sem ;) √© o valor retornado</div>
            </div>
            <div class="rule-item">
                <div class="rule-icon"><i class="fas fa-undo"></i></div>
                <div><strong>Retorno expl√≠cito</strong>: Use <code>return</code> para retornar antes do final</div>
            </div>
            <div class="rule-item">
                <div class="rule-icon"><i class="fas fa-list"></i></div>
                <div><strong>Par√¢metros</strong>: Sempre devem ter tipo especificado</div>
            </div>
            <div class="rule-item">
                <div class="rule-icon"><i class="fas fa-tag"></i></div>
                <div><strong>Tipo de retorno</strong>: Especificado ap√≥s <code>-></code></div>
            </div>
        </div>

        <h2 class="section-subtitle">Controle de Fluxo</h2>
        
        <h3>If como Express√£o</h3>
        <p>Em Rust, <code>if</code> √© uma express√£o, n√£o apenas uma declara√ß√£o. Isso significa que pode retornar um valor:</p>
        
        <div class="code-block">
let numero = 7;

<span class="comment">// If como express√£o</span>
let tipo = <span class="highlight">if</span> numero % 2 == 0 {
    "par"
} <span class="highlight">else</span> {
    "√≠mpar"
};

println!("{} √© {}", numero, tipo);

<span class="comment">// If tradicional</span>
<span class="highlight">if</span> numero > 10 {
    println!("N√∫mero grande!");
} <span class="highlight">else if</span> numero > 5 {
    println!("N√∫mero m√©dio!");
} <span class="highlight">else</span> {
    println!("N√∫mero pequeno!");
}
        </div>

        <h3>Loops</h3>
        <p>Rust oferece v√°rias formas de criar loops:</p>
        
        <div class="two-columns">
            <div>
                <h4>Loop com Range</h4>
                <div class="code-block">
<span class="comment">// Loop de 1 a 5 (inclusivo)</span>
<span class="highlight">for</span> i in 1..=5 {
    println!("i = {}", i);
}

<span class="comment">// Loop de 0 a 4 (exclusivo)</span>
<span class="highlight">for</span> i in 0..5 {
    println!("i = {}", i);
}

<span class="comment">// Iterando sobre array</span>
let numeros = [1, 2, 3, 4, 5];
<span class="highlight">for</span> numero in numeros {
    println!("n√∫mero: {}", numero);
}
                </div>
            </div>
            
            <div>
                <h4>While e Loop</h4>
                <div class="code-block">
<span class="comment">// Loop condicional</span>
let mut contador = 0;
<span class="highlight">while</span> contador < 3 {
    println!("contador: {}", contador);
    contador += 1;
}

<span class="comment">// Loop infinito</span>
let mut x = 0;
<span class="highlight">loop</span> {
    x += 1;
    if x == 5 {
        <span class="highlight">break</span>; <span class="comment">// Sai do loop</span>
    }
    if x % 2 == 0 {
        <span class="highlight">continue</span>; <span class="comment">// Pula para pr√≥xima itera√ß√£o</span>
    }
    println!("x = {}", x);
}
                </div>
            </div>
        </div>

        <h3>Pattern Matching com match</h3>
        <p>O <code>match</code> √© uma das caracter√≠sticas mais poderosas do Rust. √â como um <code>switch</code> superpoderoso:</p>
        
        <div class="code-block">
let numero = 3;

<span class="highlight">match</span> numero {
    0 => println!("Zero!"),
    1 => println!("Um!"),
    2 | 3 => println!("Dois ou tr√™s!"), <span class="comment">// M√∫ltiplos valores</span>
    4..=9 => println!("Entre 4 e 9!"),   <span class="comment">// Range</span>
    _ => println!("Outro n√∫mero!"),      <span class="comment">// Catch-all</span>
}

<span class="comment">// Match como express√£o</span>
let descricao = <span class="highlight">match</span> numero {
    0 => "zero",
    1..=5 => "pequeno",
    6..=10 => "m√©dio",
    _ => "grande",
};

println!("O n√∫mero {} √© {}", numero, descricao);
        </div>
        
        <div class="info-box">
            <h4><i class="fas fa-star"></i> Poder do Match</h4>
            <p>O <code>match</code> em Rust √© <strong>exaustivo</strong>, ou seja, voc√™ deve cobrir todos os casos poss√≠veis. O compilador garante que voc√™ n√£o esque√ßa nenhum caso!</p>
        </div>

        <h2 class="section-subtitle">Exemplo Pr√°tico</h2>
        
        <p>Vamos criar um programa que demonstra todos esses conceitos:</p>
        
        <div class="code-block">
fn calcular_categoria_idade(idade: u32) -> &'static str {
    <span class="highlight">match</span> idade {
        0..=12 => "crian√ßa",
        13..=17 => "adolescente",
        18..=64 => "adulto",
        _ => "idoso",
    }
}

fn eh_par(numero: i32) -> bool {
    numero % 2 == 0
}

fn main() {
    <span class="comment">// Vari√°veis</span>
    let nome = "Ana";
    let mut idade = 25;
    let altura = 1.65;
    
    println!("Nome: {}", nome);
    println!("Idade: {} anos", idade);
    println!("Altura: {:.2}m", altura);
    
    <span class="comment">// Usando fun√ß√µes</span>
    let categoria = calcular_categoria_idade(idade);
    println!("Categoria: {}", categoria);
    
    <span class="comment">// Controle de fluxo</span>
    <span class="highlight">if</span> eh_par(idade as i32) {
        println!("Idade √© par");
    } <span class="highlight">else</span> {
        println!("Idade √© √≠mpar");
    }
    
    <span class="comment">// Loop</span>
    println!("Contando at√© a idade:");
    <span class="highlight">for</span> i in 1..=idade {
        <span class="highlight">if</span> i % 5 == 0 {
            println!("  {} (m√∫ltiplo de 5!)", i);
        }
    }
    
    <span class="comment">// Modificando vari√°vel mut√°vel</span>
    idade += 1;
    println!("No pr√≥ximo ano ter√° {} anos", idade);
}
        </div>

        <div class="info-box">
            <h4><i class="fas fa-graduation-cap"></i> Voc√™ Aprendeu</h4>
            <ul>
                <li>Vari√°veis s√£o imut√°veis por padr√£o, use <code>mut</code> para mutabilidade</li>
                <li>Rust tem tipos est√°ticos mas infere automaticamente na maioria dos casos</li>
                <li>Fun√ß√µes podem ter retorno impl√≠cito (√∫ltima express√£o sem ;)</li>
                <li><code>if</code> √© uma express√£o que pode retornar valores</li>
                <li>Loops: <code>for</code>, <code>while</code> e <code>loop</code></li>
                <li><code>match</code> √© um pattern matching poderoso e exaustivo</li>
            </ul>
        </div>

        <div class="nav-buttons">
            <a href="primeiro-projeto.html" class="nav-button">
                <i class="fas fa-arrow-left"></i> Iniciando Um Projeto
            </a>
            <a href="ownership.html" class="nav-button">
                Ownership <i class="fas fa-arrow-right"></i>
            </a>
        </div>
    </main>

    <footer class="footer">
        <div class="container">
            <p>&copy; 2025 Tutorial de Rust.</p>
        </div>
    </footer>
</body>
</html>

